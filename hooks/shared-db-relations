#!/usr/bin/python
#
# Create relations between a shared database to many peers.
# Join does nothing.   Peer requests access to $DATABASE from $REMOTE_HOST.
# It's up to the hooks to ensure database exists, peer has access and
# clean up grants after a broken/departed peer (TODO)
#
# Author: Adam Gandelman <adam.gandelman@canonical.com>


from common import *
import sys
import subprocess
import json
import socket
import os
import utils


def pwgen():
    return subprocess.check_output(['pwgen', '-s', '16']).strip()


def relation_get():
    return json.loads(subprocess.check_output(
                        ['relation-get',
                         '--format',
                         'json']
                        )
                      )


def relation_set(**kwargs):
    cmd = [ 'relation-set' ]
    args = []
    for k, v in kwargs.items():
        if k == 'rid':
            cmd.append('-r')
            cmd.append(v)
        else:
            args.append('{}={}'.format(k, v))
    cmd += args
    subprocess.check_call(cmd)


def shared_db_changed():

    def configure_db(hostname,
                     database,
                     username):
        passwd_file = "/var/lib/mysql/mysql-{}.passwd"\
                        .format(username)
        if hostname != local_hostname:
            remote_ip = socket.gethostbyname(hostname)
        else:
            remote_ip = '127.0.0.1'

        if not os.path.exists(passwd_file):
            password = pwgen()
            with open(passwd_file, 'w') as pfile:
                pfile.write(password)
        else:
            with open(passwd_file) as pfile:
                password = pfile.read().strip()

        if not database_exists(database):
            create_database(database)
        if not grant_exists(database,
                            username,
                            remote_ip):
            create_grant(database,
                         username,
                         remote_ip, password)
        return password


    if not utils.is_clustered():
        utils.juju_log('INFO',
                       'MySQL service is not clustered, continuing shared-db relation')
    elif utils.eligible_leader():
        utils.juju_log('INFO',
                       'Cluster leader, continuing shared-db relation')
    else:
        utils.juju_log('INFO',
                       'This is not the Cluster leader, bailing shared-db relation...')
        return

    settings = relation_get()
    local_hostname = socket.getfqdn()
    singleset = set([ 
        'database',
        'username',
        'hostname'
        ])

    if singleset.issubset(settings):
        # Process a single database configuration
        password = configure_db(settings['hostname'],
                                settings['database'],
                                settings['username'])
        relation_set(db_host=local_hostname,
                     password=password)
    else:
        # Process multiple database setup requests.
        # from incoming relation data:
        #  nova_database=xxx nova_username=xxx nova_hostname=xxx
        #  quantum_database=xxx quantum_username=xxx quantum_hostname=xxx
        # create
        #{
        #   "nova": {
        #        "username": xxx,
        #        "database": xxx,
        #        "hostname": xxx
        #    },
        #    "quantum": {
        #        "username": xxx,
        #        "database": xxx,
        #        "hostname": xxx
        #    }
        #}
        #
        databases = {}
        for k, v in settings.iteritems():
            db = k.split('_')[0]
            x = '_'.join(k.split('_')[1:])
            if db not in databases:
                databases[db] = {}
            databases[db][x] = v
        return_data = {}
        for db in databases:
            if singleset.issubset(databases[db]):
                return_data['_'.join([ db, 'password' ])] = \
                    configure_db(databases[db]['hostname'],
                                 databases[db]['database'],
                                 databases[db]['username'])
        relation_set(**return_data)
        relation_set(db_host=local_hostname)

hook = os.path.basename(sys.argv[0])
hooks = {
    "shared-db-relation-changed": shared_db_changed
    }
try:
    hook_func = hooks[hook]
except KeyError:
    pass
else:
    hook_func()

sys.exit(0)
