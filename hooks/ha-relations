#!/usr/bin/env python

import json
import sys
import subprocess
import os
import time
import commands

import utils
import ceph

STORAGEMARKER = '/var/lib/juju/storageconfigured'

# CEPH
DATA_SRC_DST = '/var/lib/mysql'
SERVICE_NAME = utils.get_unit_name().replace('-','/').split('/')[0]
POOL_NAME = SERVICE_NAME

config=json.loads(subprocess.check_output(['config-get','--format=json']))


def ha_relation_joined():

    # Checking vip values
    if not 'vip' in config:
        utils.juju_log('WARNING', 'NO Virtual IP was defined, bailing')
        sys.exit(1)

    if config['vip_iface'] == "None" or not config['vip_iface']:
        utils.juju_log('WARNING', 'NO Virtual IP interface was defined, bailing')
        sys.exit(1)

    if config['vip_cidr'] == "None" or not config['vip_cidr']:
        utils.juju_log('WARNING', 'NO CIDR was defined for the Virtual IP, bailing')
        sys.exit(1)

    # Obtain the config values necessary for the cluster config. These
    # include multicast port and interface to bind to.
    corosync_bindiface = config['ha-bindiface']
    corosync_mcastport = config['ha-mcastport']

    # Starting configuring resources.
    init_services = {
            'res_mysqld':'mysql',
        }


    # If the 'ha' relation has been made *before* the 'ceph' relation,
    # it doesn't make sense to make it until after the 'ceph' relation
    # is made
    if not utils.is_relation_made('ceph'):
        utils.juju_log('INFO',
                '*ceph* relation does not exist. Not sending *ha* relation data')
        return
    else:
        utils.juju_log('INFO',
                    '*ceph* relation exists. Sending *ha* relation data')

        block_storage = 'ceph'

        resources = {
                'res_mysql_rbd':'ocf:ceph:rbd',
                'res_mysql_fs':'ocf:heartbeat:Filesystem',
                'res_mysql_vip':'ocf:heartbeat:IPaddr2',
                'res_mysqld':'upstart:mysql',
            }

        resource_params = {
                'res_mysql_rbd':'params name="%s" pool="images" user="%s" secret="%s"' % (
                                config['rbd-name'], SERVICE_NAME, ceph.keyfile_path(SERVICE_NAME)),
                'res_mysql_fs':'params device="/dev/rbd/%s/%s" directory="%s" fstype="ext4" op start start-delay="10s"' % (
                                POOL_NAME, config['rbd-name'], DATA_SRC_DST),
                'res_mysql_vip':'params ip="%s" cidr_netmask="%s" nic="%s"' % (config['vip'],
                                config['vip_cidr'], config['vip_iface']),
                'res_mysqld':'op start start-delay="5s" op monitor interval="5s"',
            }

        groups = {
                'grp_mysql':'res_mysql_rbd res_mysql_fs res_mysql_vip res_mysqld',
            }

        for rel_id in utils.relation_ids('ha'):
            utils.relation_set(rid=rel_id,
                               block_storage=block_storage,
                               corosync_bindiface=corosync_bindiface,
                               corosync_mcastport=corosync_mcastport,
                               resources=resources,
                               resource_params=resource_params,
                               init_services=init_services,
                               groups=groups)


def ha_relation_changed():
    relation_data = utils.relation_get_dict()
    if ('clustered' in relation_data and
        utils.is_leader()):
        utils.juju_log('INFO', 'Cluster configured, notifying other services')
        # Tell all related services to start using
        # the VIP
        for r_id in utils.relation_ids('shared-db'):
            utils.relation_set(rid=r_id,
                           db_host=config['vip'])


def ceph_joined():
    utils.juju_log('INFO', 'Start Ceph Relation Joined')
    ceph.install()
    utils.juju_log('INFO', 'Finish Ceph Relation Joined')


def ceph_changed():
    utils.juju_log('INFO', 'Start Ceph Relation Changed')

    # TODO: ask james: What happens if the relation data has changed?
    # do we reconfigure ceph? What do we do with the data?
    auth = utils.relation_get('auth')
    key = utils.relation_get('key')
    if None in [auth, key]:
        utils.juju_log('INFO', 'Missing key or auth in relation')
        sys.exit(0)


    ceph.configure(service=SERVICE_NAME, key=key, auth=auth)

    if utils.eligible_leader():
        sizemb = int(config['block-size'].split('G')[0]) * 1024
        rbd_img = config['rbd-name']
        blk_device = '/dev/rbd/%s/%s' % (POOL_NAME, rbd_img)
        ceph.ensure_ceph_storage(service=SERVICE_NAME, pool=POOL_NAME,
                                 rbd_img=rbd_img, sizemb=sizemb,
                                 fstype='ext4', mount_point=DATA_SRC_DST,
                                 blk_device=blk_device,
                                 system_services=['mysql'])
    else:
        utils.juju_log('INFO',
                       'This is not the peer leader. Not configuring RBD.')
        # Stopping MySQL
        if utils.running('mysql'):
            utils.juju_log('INFO','Stopping MySQL...')
            utils.stop('mysql')


    # If 'ha' relation has been made before the 'ceph' relation
    # it is important to make sure the ha-relation data is being
    # sent.
    if utils.is_relation_made('ha'):
        utils.juju_log('INFO',
                       '*ha* relation exists. Making sure the ha relation data is sent.')
        ha_relation_joined()
        return
    else:
        utils.juju_log('INFO',
                       '*ha* relation does not exist.')

    utils.juju_log('INFO', 'Finish Ceph Relation Changed')


def cluster_changed():
    utils.juju_log('INFO', 'Begin cluster changed hook.')

    if config['block-size'] == "None":
        utils.juju_log('WARNING', 'NO block storage size configured, bailing')
        return

    utils.juju_log('INFO', 'End install hook.')


hooks = {
    "cluster-relation-changed": cluster_changed,
    "ha-relation-joined": ha_relation_joined,
    "ha-relation-changed": ha_relation_changed,
    "ceph-relation-joined": ceph_joined,
    "ceph-relation-changed": ceph_changed,
}

# keystone-hooks gets called by symlink corresponding to the requested relation
# hook.
arg0 = sys.argv[0].split("/").pop()
if arg0 not in hooks.keys():
    error_out("Unsupported hook: %s" % arg0)
hooks[arg0]()
